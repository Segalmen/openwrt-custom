#!/bin/sh
set -x
# Cero3 / modified layer_cake.qos
# - QDISC = CAKE
# - Uses ctinfo to restore DSCP on ingress
# - Uses nftables (inet table sqm_dscp) to store DSCP into conntrack mark
#
# All remaining options (diffserv4, dual-srchost, dual-dsthost, nat, etc.)
# are inherited from /etc/config/sqm via EQDISC_OPTS / IQDISC_OPTS.

. ${SQM_LIB_DIR}/defaults.sh
QDISC=cake

# egress(): upload (LAN -> WAN, on $IFACE)
egress() {
    # Remove existing root qdisc
    SILENT=1 $TC qdisc del dev $IFACE root 2>/dev/null

    # Attach CAKE as root qdisc
    $TC qdisc add dev $IFACE root $( get_stab_string ) cake \
        bandwidth ${UPLINK}kbit $( get_cake_lla_string ) \
        ${EGRESS_CAKE_OPTS} ${EQDISC_OPTS}

    # (Optional) Restore DSCP from conntrack on upload as well
    # Uncomment if needed:
    #
    # $TC filter add dev $IFACE parent root protocol all matchall \
    #     action ctinfo dscp 63 128
}

# ingress(): download (WAN -> LAN, via IFB $DEV)
ingress() {

    # Remove existing ingress qdisc on WAN interface
    SILENT=1 $TC qdisc del dev $IFACE handle ffff: ingress 2>/dev/null
    $TC qdisc add dev $IFACE handle ffff: ingress

    # Remove existing CAKE qdisc on IFB
    SILENT=1 $TC qdisc del dev $DEV root 2>/dev/null

    # Apply DSCP ignore / wash options if requested by SQM
    [ "$IGNORE_DSCP_INGRESS" -eq "1" ] && INGRESS_CAKE_OPTS="$INGRESS_CAKE_OPTS besteffort"
    [ "$ZERO_DSCP_INGRESS"  -eq "1" ] && INGRESS_CAKE_OPTS="$INGRESS_CAKE_OPTS wash"

    # Attach CAKE on IFB for download shaping
    $TC qdisc add dev $DEV root $( get_stab_string ) cake \
        bandwidth ${DOWNLINK}kbit $( get_cake_lla_string ) \
        ${INGRESS_CAKE_OPTS} ${IQDISC_OPTS}

    # Bring IFB interface up
    $IP link set dev $DEV up

    # Redirect ingress traffic (WAN -> IFB) and restore DSCP from conntrack
    # ctinfo reads the conntrack mark (populated by nftables) and restores DSCP
    $TC filter add dev $IFACE parent ffff: protocol all matchall \
        action ctinfo dscp 63 128 \
        mirred egress redirect dev $DEV
}

########################################
#        nftables: sqm_dscp            #
########################################

# Try to automatically identify the SQM section matching $IFACE
SQM_SECTION="$(uci -q show sqm | sed -n "s/^\(sqm\.[^.]*\)\.interface='$IFACE'$/\1/p" | head -n1)"

# Fallback to the first queue section if none is found (rare case)
[ -z "$SQM_SECTION" ] && SQM_SECTION="sqm.@queue[0]"

setup_nftables() {
    # Reload UCI parameters for the SQM section bound to $IFACE

    GAMING_IP="$(uci -q get ${SQM_SECTION}.gaming_ip || echo '192.168.1.100')"
    [ -z "$GAMING_IP" ] && GAMING_IP="192.168.1.100"
    GAMING_IP_SET="{ $(echo "$GAMING_IP" | sed 's/,/, /g') }"

    # Gaming IPv6
    GAMING_IP6="$(uci -q get ${SQM_SECTION}.gaming_ip6 || echo '2001:db8::100')"
    [ -z "$GAMING_IP6" ] && GAMING_IP6="2001:db8::100"
    GAMING_IP6_SET="{ $(echo "$GAMING_IP6" | sed 's/,/, /g') }"

    GAMING_DSCP="$(uci -q get ${SQM_SECTION}.gaming_dscp || echo 'ef')"
    GAMING_DSCP="$(printf '%s\n' "$GAMING_DSCP" | awk '{print tolower($0)}')"

    GAMING_UDP_PORTS="$(uci -q get ${SQM_SECTION}.gaming_udp_ports || echo '3659,3074,3478-3480,10000-45000')"
    [ -z "$GAMING_UDP_PORTS" ] && GAMING_UDP_PORTS="3659,3074,3478-3480,10000-45000"

    GAMING_TCP_PORTS="$(uci -q get ${SQM_SECTION}.gaming_tcp_ports || echo '')"

    BROWSING_ENABLE="$(uci -q get ${SQM_SECTION}.browsing_enable || echo '0')"

    BROWSING_DSCP="$(uci -q get ${SQM_SECTION}.browsing_dscp || echo 'cs1')"
    BROWSING_DSCP="$(printf '%s\n' "$BROWSING_DSCP" | awk '{print tolower($0)}')"

    BROWSING_TCP_PORTS="$(uci -q get ${SQM_SECTION}.browsing_tcp_ports || echo '80,8080,443')"
    BROWSING_UDP_PORTS="$(uci -q get ${SQM_SECTION}.browsing_udp_ports || echo '443')"

    GAMING_BULK_ENABLE="$(uci -q get ${SQM_SECTION}.gaming_bulk_enable || echo '0')"
    GAMING_BULK_DSCRAW="$(uci -q get ${SQM_SECTION}.gaming_bulk_dscp || echo 'cs1')"
    GAMING_BULK_DSCRAW="$(printf '%s\n' "$GAMING_BULK_DSCRAW" | awk '{print tolower($0)}')"
    GAMING_BULK_DSCP="$GAMING_BULK_DSCRAW"

    # Clean up any existing sqm_dscp table
    nft delete table inet sqm_dscp >/dev/null 2>&1

    #########################
	#  HEREDOC -> nft      #
	#########################
    nft -f - << EOF
add table inet sqm_dscp

add chain inet sqm_dscp sqm_dscp {
    type filter hook postrouting priority mangle;
    policy accept;
}

# Gaming UDP IPv4
add rule inet sqm_dscp sqm_dscp \
    ip saddr $GAMING_IP_SET udp sport { $GAMING_UDP_PORTS } \
    counter ip dscp set $GAMING_DSCP comment "Gaming UDP UP $GAMING_DSCP (sqm)"

add rule inet sqm_dscp sqm_dscp \
    ip daddr $GAMING_IP_SET udp dport { $GAMING_UDP_PORTS } \
    counter ip dscp set $GAMING_DSCP comment "Gaming UDP DOWN $GAMING_DSCP (sqm)"

# Gaming UDP IPv6
add rule inet sqm_dscp sqm_dscp \
    ip6 saddr $GAMING_IP6_SET udp sport { $GAMING_UDP_PORTS } \
    counter ip6 dscp set $GAMING_DSCP comment "Gaming UDP UP v6 $GAMING_DSCP (sqm)"

add rule inet sqm_dscp sqm_dscp \
    ip6 daddr $GAMING_IP6_SET udp dport { $GAMING_UDP_PORTS } \
    counter ip6 dscp set $GAMING_DSCP comment "Gaming UDP DOWN v6 $GAMING_DSCP (sqm)"
EOF
    #########################
	#  END HEREDOC         #
	#  From here on:       #
	#  shell commands      #
	#########################

    # --- Gaming TCP  ---
    if [ -n "$GAMING_TCP_PORTS" ]; then
        nft add rule inet sqm_dscp sqm_dscp \
            ip saddr $GAMING_IP_SET tcp sport { $GAMING_TCP_PORTS } \
            counter ip dscp set $GAMING_DSCP \
            comment "\"Gaming TCP UP $GAMING_DSCP (sqm)\""

        nft add rule inet sqm_dscp sqm_dscp \
            ip daddr $GAMING_IP_SET tcp dport { $GAMING_TCP_PORTS } \
            counter ip dscp set $GAMING_DSCP \
            comment "\"Gaming TCP DOWN $GAMING_DSCP (sqm)\""

        nft add rule inet sqm_dscp sqm_dscp \
            ip6 saddr $GAMING_IP6_SET tcp sport { $GAMING_TCP_PORTS } \
            counter ip6 dscp set $GAMING_DSCP \
            comment "\"Gaming TCP UP v6 $GAMING_DSCP (sqm)\""

        nft add rule inet sqm_dscp sqm_dscp \
            ip6 daddr $GAMING_IP6_SET tcp dport { $GAMING_TCP_PORTS } \
            counter ip6 dscp set $GAMING_DSCP \
            comment "\"Gaming TCP DOWN v6 $GAMING_DSCP (sqm)\""
    fi

    # --- Browsing 80/443 (global) ---
    if [ "$BROWSING_ENABLE" = "1" ]; then
        # TCP : IPv4 + IPv6
        if [ -n "$BROWSING_TCP_PORTS" ]; then
            nft add rule inet sqm_dscp sqm_dscp \
                tcp dport { $BROWSING_TCP_PORTS } \
                counter ip dscp set $BROWSING_DSCP \
                comment "\"Browsing TCP v4 -> $BROWSING_DSCP (sqm)\""

            nft add rule inet sqm_dscp sqm_dscp \
                tcp dport { $BROWSING_TCP_PORTS } \
                counter ip6 dscp set $BROWSING_DSCP \
                comment "\"Browsing TCP v6 -> $BROWSING_DSCP (sqm)\""
        fi

        # UDP : IPv4 + IPv6
        if [ -n "$BROWSING_UDP_PORTS" ]; then
            nft add rule inet sqm_dscp sqm_dscp \
                udp dport { $BROWSING_UDP_PORTS } \
                counter ip dscp set $BROWSING_DSCP \
                comment "\"Browsing UDP v4 -> $BROWSING_DSCP (sqm)\""

            nft add rule inet sqm_dscp sqm_dscp \
                udp dport { $BROWSING_UDP_PORTS } \
                counter ip6 dscp set $BROWSING_DSCP \
                comment "\"Browsing UDP v6 -> $BROWSING_DSCP (sqm)\""
        fi
    fi

    # --- PS5 bulk (HTTP/HTTPS) : gaming IP ports browsing, DSCP ---
    if [ "$GAMING_BULK_ENABLE" = "1" ]; then
        # IPv4 TCP
        if [ -n "$BROWSING_TCP_PORTS" ]; then
            nft add rule inet sqm_dscp sqm_dscp \
                ip saddr $GAMING_IP_SET tcp dport { $BROWSING_TCP_PORTS } \
                counter ip dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK TCP v4 UP -> $GAMING_BULK_DSCP (sqm)\""

            nft add rule inet sqm_dscp sqm_dscp \
                ip daddr $GAMING_IP_SET tcp dport { $BROWSING_TCP_PORTS } \
                counter ip dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK TCP v4 DOWN -> $GAMING_BULK_DSCP (sqm)\""
        fi

        # IPv4 UDP
        if [ -n "$BROWSING_UDP_PORTS" ]; then
            nft add rule inet sqm_dscp sqm_dscp \
                ip saddr $GAMING_IP_SET udp dport { $BROWSING_UDP_PORTS } \
                counter ip dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK UDP v4 UP -> $GAMING_BULK_DSCP (sqm)\""

            nft add rule inet sqm_dscp sqm_dscp \
                ip daddr $GAMING_IP_SET udp dport { $BROWSING_UDP_PORTS } \
                counter ip dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK UDP v4 DOWN -> $GAMING_BULK_DSCP (sqm)\""
        fi

        # IPv6 TCP
        if [ -n "$BROWSING_TCP_PORTS" ]; then
            nft add rule inet sqm_dscp sqm_dscp \
                ip6 saddr $GAMING_IP6_SET tcp dport { $BROWSING_TCP_PORTS } \
                counter ip6 dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK TCP v6 UP -> $GAMING_BULK_DSCP (sqm)\""

            nft add rule inet sqm_dscp sqm_dscp \
                ip6 daddr $GAMING_IP6_SET tcp dport { $BROWSING_TCP_PORTS } \
                counter ip6 dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK TCP v6 DOWN -> $GAMING_BULK_DSCP (sqm)\""
        fi

        # IPv6 UDP
        if [ -n "$BROWSING_UDP_PORTS" ]; then
            nft add rule inet sqm_dscp sqm_dscp \
                ip6 saddr $GAMING_IP6_SET udp dport { $BROWSING_UDP_PORTS } \
                counter ip6 dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK UDP v6 UP -> $GAMING_BULK_DSCP (sqm)\""

            nft add rule inet sqm_dscp sqm_dscp \
                ip6 daddr $GAMING_IP6_SET udp dport { $BROWSING_UDP_PORTS } \
                counter ip6 dscp set $GAMING_BULK_DSCP \
                comment "\"Gaming BULK UDP v6 DOWN -> $GAMING_BULK_DSCP (sqm)\""
        fi
    fi

    # --- Store DSCP -> CTMARK ---
    nft 'add rule inet sqm_dscp sqm_dscp ct mark set ip dscp or 0x80 counter comment "Store DSCP IPv4 into ctmark"'
    nft 'add rule inet sqm_dscp sqm_dscp ct mark set ip6 dscp or 0x80 counter comment "Store DSCP IPv6 into ctmark"'
}

cleanup_nftables() {
    nft delete table inet sqm_dscp >/dev/null 2>&1 || true
}


	########################################
	#     Hooks used by sqm-scripts   #
	########################################

sqm_prepare_script() {
    # Load required modules and verify CAKE availability
    do_modules
    verify_qdisc $QDISC "cake" || return 1

    # Prepare nftables table to store DSCP into conntrack
    setup_nftables
}

sqm_cleanup_script() {
    # Clean up nftables sqm_dscp table
    cleanup_nftables
}

sqm_cleanup() {
    local silent
    silent=${1:-0}

    # Revert any legacy iptables commands accumulated by SQM
    ipt_log_rewind

    # Remove IFB interface used by CAKE if present
    [ -n "$CUR_IFB" ] || return 0

    SILENT=$silent $IP link delete dev ${CUR_IFB} type ifb 2>/dev/null
    sqm_debug "${0}: ${CUR_IFB} interface deleted"

    # nftables-specific cleanup
    sqm_cleanup_script
}


sqm_stop() {
    # Remove ingress qdisc on $IFACE if used
    [ "${DOWNLINK}" -ne 0 ] && $TC qdisc del dev $IFACE ingress 2>/dev/null

    # Remove CAKE root qdisc on $IFACE (upload)
    $TC qdisc del dev $IFACE root 2>/dev/null

    # Global cleanup (IFB + nftables)
    sqm_cleanup
}

